//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: SHIFT_REGISTER ()
//
module SHIFT_REGISTER // "system.shift_register"
(
    input logic shift_register_clock,
    input logic shift_register_reset,
    input logic [18:0] shift_register_input,
    output logic [16:0] shift_register_state,
    output logic [16:0] shift_register_output
);

//------------------------------------------------------------------------------
// Clocked THREAD: shift (shift_register.cpp:4:1) 

// Thread-local variables
logic [16:0] shift_register_state_next;
logic [16:0] shift_register_output_next;
logic [16:0] output_v;
logic [16:0] output_v_next;

// Next-state combinational logic
always_comb begin : shift_comb     // shift_register.cpp:4:1
    shift_func;
end
function void shift_func;
    logic [16:0] TMP_0;
    logic [16:0] output_v_1;
    logic [16:0] TMP_1;
    logic [16:0] input_v;
    integer index;
    integer value;
    logic [16:0] output_v_2;
    logic [16:0] TMP_2;
    logic [16:0] input_v_1;
    logic value_1;
    logic [16:0] output_v_3;
    logic [16:0] TMP_3;
    logic [16:0] TMP_4;
    logic [16:0] TMP_5;
    logic [16:0] TMP_6;
    logic [16:0] input_v_2;
    integer index_1;
    logic [16:0] output_v_4;
    logic [16:0] TMP_7;
    logic TMP_8;
    logic [16:0] input_v_3;
    logic [16:0] TMP_9;
    integer TMP_11;
    logic [18:0] input_v_4;
    integer index_2;
    logic [16:0] TMP_12;
    integer TMP_15;
    logic [16:0] TMP_16;
    TMP_6 = 0;
    output_v_4 = 0;
    TMP_7 = 0;
    TMP_8 = 0;
    input_v_3 = 0;
    TMP_9 = 0;
    TMP_11 = 0;
    TMP_12 = 0;
    TMP_15 = 0;
    TMP_16 = 0;
    output_v_next = output_v;
    shift_register_output_next = shift_register_output;
    shift_register_state_next = shift_register_state;
    input_v_2 = shift_register_state; index_1 = 1;
    // Call btint_shift_right() begin
    output_v_4 = input_v_2;
    for (integer i_1 = 0; i_1 < index_1; i_1++)
    begin
        output_v_4 = output_v_4 >>> 2;
        input_v = output_v_4; index = 8 - 1; value = 0;
        // Call btint_set_value() begin
        output_v_2 = input_v;
        case (0)
        -1 : begin
            output_v_2[2 * index] = 0;
            output_v_2[2 * index + 1] = 0;
        end
        0 : begin
            output_v_2[2 * index] = 0;
            output_v_2[2 * index + 1] = 1;
        end
        1 : begin
            output_v_2[2 * index] = 1;
            output_v_2[2 * index + 1] = 1;
        end
        default : begin
        end
        endcase
        TMP_7 = output_v_2;
        // Call btint_set_value() end
        output_v_4 = TMP_7;
    end
    input_v_3 = input_v_2;
    // Call btint_get_overflow() begin
    TMP_8 = input_v_3[2 * 8];
    // Call btint_get_overflow() end
    input_v_1 = output_v_4; value_1 = TMP_8;
    // Call btint_set_overflow() begin
    output_v_3 = input_v_1;
    output_v_3[2 * 8] = value_1;
    TMP_9 = output_v_3;
    // Call btint_set_overflow() end
    output_v_4 = TMP_9;
    TMP_6 = output_v_4;
    // Call btint_shift_right() end
    input_v_4 = shift_register_input; index_2 = 0;
    // Call btint_get_value() begin
    TMP_11 = input_v_4[2 * index_2] + input_v_4[2 * index_2 + 1] - 1;
    // Call btint_get_value() end
    input_v = TMP_6; index = 8 - 1; value = TMP_11;
    // Call btint_set_value() begin
    output_v_2 = input_v;
    case (value)
    -1 : begin
        output_v_2[2 * index] = 0;
        output_v_2[2 * index + 1] = 0;
    end
    0 : begin
        output_v_2[2 * index] = 0;
        output_v_2[2 * index + 1] = 1;
    end
    1 : begin
        output_v_2[2 * index] = 1;
        output_v_2[2 * index + 1] = 1;
    end
    default : begin
    end
    endcase
    TMP_12 = output_v_2;
    // Call btint_set_value() end
    shift_register_state_next = TMP_12;
    for (integer i_2 = 0; i_2 < 8; i_2++)
    begin
        input_v_4 = shift_register_input; index_2 = i_2 + 1;
        // Call btint_get_value() begin
        TMP_15 = input_v_4[2 * index_2] + input_v_4[2 * index_2 + 1] - 1;
        // Call btint_get_value() end
        input_v = output_v_next; index = i_2; value = TMP_15;
        // Call btint_set_value() begin
        output_v_2 = input_v;
        case (value)
        -1 : begin
            output_v_2[2 * index] = 0;
            output_v_2[2 * index + 1] = 0;
        end
        0 : begin
            output_v_2[2 * index] = 0;
            output_v_2[2 * index + 1] = 1;
        end
        1 : begin
            output_v_2[2 * index] = 1;
            output_v_2[2 * index + 1] = 1;
        end
        default : begin
        end
        endcase
        TMP_16 = output_v_2;
        // Call btint_set_value() end
        output_v_next = TMP_16;
    end
    shift_register_output_next = output_v_next;
endfunction

// Synchronous register update
always_ff @(posedge shift_register_clock /*sync shift_register_reset*/) 
begin : shift_ff
    if ( shift_register_reset ) begin
        logic [16:0] TMP_0;
        logic [16:0] output_v_1;
        logic [16:0] TMP_1;
        logic [16:0] input_v;
        integer index;
        integer value;
        logic [16:0] output_v_2;
        logic [16:0] TMP_2;
        logic [16:0] input_v_1;
        logic value_1;
        logic [16:0] output_v_3;
        logic [16:0] TMP_3;
        logic [16:0] TMP_4;
        logic [16:0] TMP_5;
        output_v <= 0;
        // Call btint_reset() begin
        output_v_1 = 0;
        for (integer i = 0; i < 8; i++)
        begin
            input_v = output_v_1; index = i; value = 0;
            // Call btint_set_value() begin
            output_v_2 = input_v;
            case (0)
            -1 : begin
                output_v_2[2 * index] = 0;
                output_v_2[2 * index + 1] = 0;
            end
            0 : begin
                output_v_2[2 * index] = 0;
                output_v_2[2 * index + 1] = 1;
            end
            1 : begin
                output_v_2[2 * index] = 1;
                output_v_2[2 * index + 1] = 1;
            end
            default : begin
            end
            endcase
            TMP_1 = output_v_2;
            // Call btint_set_value() end
            output_v_1 = TMP_1;
        end
        input_v_1 = output_v_1; value_1 = 0;
        // Call btint_set_overflow() begin
        output_v_3 = input_v_1;
        output_v_3[2 * 8] = value_1;
        TMP_2 = output_v_3;
        // Call btint_set_overflow() end
        output_v_1 = TMP_2;
        TMP_0 = output_v_1;
        // Call btint_reset() end
        shift_register_state <= TMP_0;
        // Call btint_reset() begin
        output_v_1 = 0;
        for (integer i = 0; i < 8; i++)
        begin
            input_v = output_v_1; index = i; value = 0;
            // Call btint_set_value() begin
            output_v_2 = input_v;
            case (0)
            -1 : begin
                output_v_2[2 * index] = 0;
                output_v_2[2 * index + 1] = 0;
            end
            0 : begin
                output_v_2[2 * index] = 0;
                output_v_2[2 * index + 1] = 1;
            end
            1 : begin
                output_v_2[2 * index] = 1;
                output_v_2[2 * index + 1] = 1;
            end
            default : begin
            end
            endcase
            TMP_4 = output_v_2;
            // Call btint_set_value() end
            output_v_1 = TMP_4;
        end
        input_v_1 = output_v_1; value_1 = 0;
        // Call btint_set_overflow() begin
        output_v_3 = input_v_1;
        output_v_3[2 * 8] = value_1;
        TMP_5 = output_v_3;
        // Call btint_set_overflow() end
        output_v_1 = TMP_5;
        TMP_3 = output_v_1;
        // Call btint_reset() end
        shift_register_output <= TMP_3;
    end
    else begin
        shift_register_state <= shift_register_state_next;
        shift_register_output <= shift_register_output_next;
        output_v <= output_v_next;
    end
end

endmodule


