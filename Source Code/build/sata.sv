//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.12
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: SHIFT_REGISTER ()
//
module SHIFT_REGISTER // "system.shift_register"
(
    input logic shift_register_clock,
    input logic shift_register_reset,
    input logic [8:0] shift_register_input_btint_a,
    input logic [8:0] shift_register_input_btint_b,
    input logic [1:0] shift_register_input_overflow,
    output logic [7:0] shift_register_state_btint_a,
    output logic [7:0] shift_register_state_btint_b,
    output logic [1:0] shift_register_state_overflow,
    output logic [7:0] shift_register_output_btint_a,
    output logic [7:0] shift_register_output_btint_b,
    output logic [1:0] shift_register_output_overflow
);

//------------------------------------------------------------------------------
// Clocked THREAD: shift (shift_register.cpp:4:1) 

// Thread-local variables
logic [7:0] shift_register_state_btint_a_next;
logic [7:0] shift_register_state_btint_b_next;
logic [1:0] shift_register_state_overflow_next;
logic [7:0] shift_register_output_btint_a_next;
logic [7:0] shift_register_output_btint_b_next;
logic [1:0] shift_register_output_overflow_next;

// Next-state combinational logic
always_comb begin : shift_comb     // shift_register.cpp:4:1
    shift_func;
end
function void shift_func;
    logic [8:0] input_btint_a;
    logic [8:0] input_btint_b;
    logic [1:0] input_overflow;
    logic [7:0] state_btint_a;
    logic [7:0] state_btint_b;
    logic [1:0] state_overflow;
    integer TMP_0_value;
    logic [7:0] output_btint_a;
    logic [7:0] output_btint_b;
    logic [1:0] output_overflow;
    integer output_index;
    integer output_value;
    logic [7:0] output_btint_a_1;
    logic [7:0] output_btint_b_1;
    logic [1:0] output_overflow_1;
    logic [7:0] TMP_2_btint_a;
    logic [7:0] TMP_2_btint_b;
    logic [1:0] TMP_2_overflow;
    logic TMP_0_isNegative;
    integer TMP_0_i;
    logic [7:0] TMP_1_btint_a;
    logic [7:0] TMP_1_btint_b;
    logic [1:0] TMP_1_overflow;
    integer TMP_3_value;
    logic [7:0] output_btint_a_2;
    logic [7:0] output_btint_b_2;
    logic [1:0] output_overflow_2;
    integer output_index_1;
    integer output_value_1;
    logic [7:0] output_btint_a_3;
    logic [7:0] output_btint_b_3;
    logic [1:0] output_overflow_3;
    logic [7:0] TMP_5_btint_a;
    logic [7:0] TMP_5_btint_b;
    logic [1:0] TMP_5_overflow;
    logic TMP_3_isNegative;
    integer TMP_3_i;
    logic [7:0] TMP_4_btint_a;
    logic [7:0] TMP_4_btint_b;
    logic [1:0] TMP_4_overflow;
    integer state_index;
    logic [7:0] output_btint_a_4;
    logic [7:0] output_btint_b_4;
    logic [1:0] output_overflow_4;
    integer output_index_2;
    integer output_value_2;
    logic [7:0] output_btint_a_5;
    logic [7:0] output_btint_b_5;
    logic [1:0] output_overflow_5;
    logic [7:0] TMP_7_btint_a;
    logic [7:0] TMP_7_btint_b;
    logic [1:0] TMP_7_overflow;
    logic [7:0] TMP_6_btint_a;
    logic [7:0] TMP_6_btint_b;
    logic [1:0] TMP_6_overflow;
    integer TMP_8;
    integer input_index;
    integer state_index_1;
    integer state_value;
    logic [7:0] output_btint_a_6;
    logic [7:0] output_btint_b_6;
    logic [1:0] output_overflow_6;
    logic [7:0] TMP_9_btint_a;
    logic [7:0] TMP_9_btint_b;
    logic [1:0] TMP_9_overflow;
    integer input_from;
    integer input_to;
    logic [7:0] output_btint_a_7;
    logic [7:0] output_btint_b_7;
    logic [1:0] output_overflow_7;
    logic [7:0] TMP_11_btint_a;
    logic [7:0] TMP_11_btint_b;
    logic [1:0] TMP_11_overflow;
    output_btint_a_4 = 0;
    output_btint_b_4 = 0;
    output_overflow_4 = 0;
    output_index_2 = 0;
    output_value_2 = 0;
    output_btint_a_5 = 0;
    output_btint_b_5 = 0;
    output_overflow_5 = 0;
    TMP_7_btint_a = 0;
    TMP_7_btint_b = 0;
    TMP_7_overflow = 0;
    TMP_6_btint_a = 0;
    TMP_6_btint_b = 0;
    TMP_6_overflow = 0;
    TMP_8 = 0;
    output_btint_a_6 = 0;
    output_btint_b_6 = 0;
    output_overflow_6 = 0;
    TMP_9_btint_a = 0;
    TMP_9_btint_b = 0;
    TMP_9_overflow = 0;
    output_btint_a_7 = 0;
    output_btint_b_7 = 0;
    output_overflow_7 = 0;
    TMP_11_btint_a = 0;
    TMP_11_btint_b = 0;
    TMP_11_overflow = 0;
    shift_register_output_btint_a_next = shift_register_output_btint_a;
    shift_register_output_btint_b_next = shift_register_output_btint_b;
    shift_register_output_overflow_next = shift_register_output_overflow;
    shift_register_state_btint_a_next = shift_register_state_btint_a;
    shift_register_state_btint_b_next = shift_register_state_btint_b;
    shift_register_state_overflow_next = shift_register_state_overflow;
    input_btint_a = shift_register_input_btint_a; input_btint_b = shift_register_input_btint_b; input_overflow = shift_register_input_overflow;
    state_btint_a = shift_register_state_btint_a; state_btint_b = shift_register_state_btint_b; state_overflow = shift_register_state_overflow;
    state_index = 1;
    // Call shift_right() begin
    output_btint_a_4 = 0;
    output_btint_b_4 = 0;
    output_overflow_4 = 0;
    output_btint_a_4 = state_btint_a;
    output_btint_b_4 = state_btint_b;
    output_overflow_4 = state_overflow;
    for (integer i_2 = 0; i_2 < state_index; i_2++)
    begin
        output_btint_a_4 = output_btint_a_4 >>> 1;
        output_btint_b_4 = output_btint_b_4 >>> 1;
        output_index_2 = 8 - 1; output_value_2 = 0;
        // Call set_value() begin
        output_btint_a_5 = 0;
        output_btint_b_5 = 0;
        output_overflow_5 = 0;
        output_btint_a_5 = output_btint_a_4;
        output_btint_b_5 = output_btint_b_4;
        output_overflow_5 = output_overflow_4;
        case (0)
        -1 : begin
            output_btint_a_5[output_index_2] = 0;
            output_btint_b_5[output_index_2] = 0;
        end
        0 : begin
            output_btint_a_5[output_index_2] = 0;
            output_btint_b_5[output_index_2] = 1;
        end
        1 : begin
            output_btint_a_5[output_index_2] = 1;
            output_btint_b_5[output_index_2] = 1;
        end
        default : begin
        end
        endcase
        TMP_7_btint_a = output_btint_a_5; TMP_7_btint_b = output_btint_b_5; TMP_7_overflow = output_overflow_5;
        // Call set_value() end
        output_btint_a_4 = TMP_7_btint_a; output_btint_b_4 = TMP_7_btint_b; output_overflow_4 = TMP_7_overflow;
    end
    TMP_6_btint_a = output_btint_a_4; TMP_6_btint_b = output_btint_b_4; TMP_6_overflow = output_overflow_4;
    // Call shift_right() end
    state_btint_a = TMP_6_btint_a; state_btint_b = TMP_6_btint_b; state_overflow = TMP_6_overflow;
    input_index = 0;
    // Call get_value() begin
    TMP_8 = input_btint_a[input_index] + input_btint_b[input_index] - 1;
    // Call get_value() end
    state_index_1 = 8 - 1; state_value = TMP_8;
    // Call set_value() begin
    output_btint_a_6 = 0;
    output_btint_b_6 = 0;
    output_overflow_6 = 0;
    output_btint_a_6 = state_btint_a;
    output_btint_b_6 = state_btint_b;
    output_overflow_6 = state_overflow;
    case (state_value)
    -1 : begin
        output_btint_a_6[state_index_1] = 0;
        output_btint_b_6[state_index_1] = 0;
    end
    0 : begin
        output_btint_a_6[state_index_1] = 0;
        output_btint_b_6[state_index_1] = 1;
    end
    1 : begin
        output_btint_a_6[state_index_1] = 1;
        output_btint_b_6[state_index_1] = 1;
    end
    default : begin
    end
    endcase
    TMP_9_btint_a = output_btint_a_6; TMP_9_btint_b = output_btint_b_6; TMP_9_overflow = output_overflow_6;
    // Call set_value() end
    state_btint_a = TMP_9_btint_a; state_btint_b = TMP_9_btint_b; state_overflow = TMP_9_overflow;
    shift_register_state_btint_a_next = state_btint_a; shift_register_state_btint_b_next = state_btint_b; shift_register_state_overflow_next = state_overflow;
    input_from = 8; input_to = 1;
    // Call range() begin
    output_btint_a_7 = 0;
    output_btint_b_7 = 0;
    output_overflow_7 = 0;
    output_btint_a_7 = input_btint_a[input_to +: 8];
    output_btint_b_7 = input_btint_b[input_to +: 8];
    output_overflow_7 = input_overflow;
    TMP_11_btint_a = output_btint_a_7; TMP_11_btint_b = output_btint_b_7; TMP_11_overflow = output_overflow_7;
    // Call range() end
    shift_register_output_btint_a_next = TMP_11_btint_a; shift_register_output_btint_b_next = TMP_11_btint_b; shift_register_output_overflow_next = TMP_11_overflow;
endfunction

// Synchronous register update
always_ff @(posedge shift_register_clock /*sync shift_register_reset*/) 
begin : shift_ff
    if ( shift_register_reset ) begin
        logic [8:0] input_btint_a;
        logic [8:0] input_btint_b;
        logic [1:0] input_overflow;
        logic [7:0] state_btint_a;
        logic [7:0] state_btint_b;
        logic [1:0] state_overflow;
        integer TMP_0_value;
        logic [7:0] output_btint_a;
        logic [7:0] output_btint_b;
        logic [1:0] output_overflow;
        integer output_index;
        integer output_value;
        logic [7:0] output_btint_a_1;
        logic [7:0] output_btint_b_1;
        logic [1:0] output_overflow_1;
        logic [7:0] TMP_2_btint_a;
        logic [7:0] TMP_2_btint_b;
        logic [1:0] TMP_2_overflow;
        logic TMP_0_isNegative;
        integer TMP_0_i;
        logic [7:0] TMP_1_btint_a;
        logic [7:0] TMP_1_btint_b;
        logic [1:0] TMP_1_overflow;
        integer TMP_3_value;
        logic [7:0] output_btint_a_2;
        logic [7:0] output_btint_b_2;
        logic [1:0] output_overflow_2;
        integer output_index_1;
        integer output_value_1;
        logic [7:0] output_btint_a_3;
        logic [7:0] output_btint_b_3;
        logic [1:0] output_overflow_3;
        logic [7:0] TMP_5_btint_a;
        logic [7:0] TMP_5_btint_b;
        logic [1:0] TMP_5_overflow;
        logic TMP_3_isNegative;
        integer TMP_3_i;
        logic [7:0] TMP_4_btint_a;
        logic [7:0] TMP_4_btint_b;
        logic [1:0] TMP_4_overflow;
        input_btint_a = 0;
        input_btint_b = 0;
        input_overflow = 0;
        state_btint_a = 0;
        state_btint_b = 0;
        state_overflow = 0;
        TMP_0_value = 0;
        // Call from_int() begin
        output_btint_a = 0;
        output_btint_b = 0;
        output_overflow = 0;
        for (integer i = 0; i < 8; i++)
        begin
            output_index = i; output_value = 0;
            // Call set_value() begin
            output_btint_a_1 = 0;
            output_btint_b_1 = 0;
            output_overflow_1 = 0;
            output_btint_a_1 = output_btint_a;
            output_btint_b_1 = output_btint_b;
            output_overflow_1 = output_overflow;
            case (0)
            -1 : begin
                output_btint_a_1[output_index] = 0;
                output_btint_b_1[output_index] = 0;
            end
            0 : begin
                output_btint_a_1[output_index] = 0;
                output_btint_b_1[output_index] = 1;
            end
            1 : begin
                output_btint_a_1[output_index] = 1;
                output_btint_b_1[output_index] = 1;
            end
            default : begin
            end
            endcase
            TMP_2_btint_a = output_btint_a_1; TMP_2_btint_b = output_btint_b_1; TMP_2_overflow = output_overflow_1;
            // Call set_value() end
            output_btint_a = TMP_2_btint_a; output_btint_b = TMP_2_btint_b; output_overflow = TMP_2_overflow;
        end
        TMP_0_isNegative = TMP_0_value < 0;
        TMP_0_i = 0;
        TMP_1_btint_a = output_btint_a; TMP_1_btint_b = output_btint_b; TMP_1_overflow = output_overflow;
        // Call from_int() end
        shift_register_state_btint_a <= TMP_1_btint_a; shift_register_state_btint_b <= TMP_1_btint_b; shift_register_state_overflow <= TMP_1_overflow;
        TMP_3_value = 0;
        // Call from_int() begin
        output_btint_a_2 = 0;
        output_btint_b_2 = 0;
        output_overflow_2 = 0;
        for (integer i_1 = 0; i_1 < 8; i_1++)
        begin
            output_index_1 = i_1; output_value_1 = 0;
            // Call set_value() begin
            output_btint_a_3 = 0;
            output_btint_b_3 = 0;
            output_overflow_3 = 0;
            output_btint_a_3 = output_btint_a_2;
            output_btint_b_3 = output_btint_b_2;
            output_overflow_3 = output_overflow_2;
            case (0)
            -1 : begin
                output_btint_a_3[output_index_1] = 0;
                output_btint_b_3[output_index_1] = 0;
            end
            0 : begin
                output_btint_a_3[output_index_1] = 0;
                output_btint_b_3[output_index_1] = 1;
            end
            1 : begin
                output_btint_a_3[output_index_1] = 1;
                output_btint_b_3[output_index_1] = 1;
            end
            default : begin
            end
            endcase
            TMP_5_btint_a = output_btint_a_3; TMP_5_btint_b = output_btint_b_3; TMP_5_overflow = output_overflow_3;
            // Call set_value() end
            output_btint_a_2 = TMP_5_btint_a; output_btint_b_2 = TMP_5_btint_b; output_overflow_2 = TMP_5_overflow;
        end
        TMP_3_isNegative = TMP_3_value < 0;
        TMP_3_i = 0;
        TMP_4_btint_a = output_btint_a_2; TMP_4_btint_b = output_btint_b_2; TMP_4_overflow = output_overflow_2;
        // Call from_int() end
        shift_register_output_btint_a <= TMP_4_btint_a; shift_register_output_btint_b <= TMP_4_btint_b; shift_register_output_overflow <= TMP_4_overflow;
    end
    else begin
        shift_register_state_btint_a <= shift_register_state_btint_a_next;
        shift_register_state_btint_b <= shift_register_state_btint_b_next;
        shift_register_state_overflow <= shift_register_state_overflow_next;
        shift_register_output_btint_a <= shift_register_output_btint_a_next;
        shift_register_output_btint_b <= shift_register_output_btint_b_next;
        shift_register_output_overflow <= shift_register_output_overflow_next;
    end
end

endmodule


