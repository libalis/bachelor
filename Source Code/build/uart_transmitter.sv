//==============================================================================
//
// The code is generated by Intel Compiler for SystemC, version 1.6.17
// see more information at https://github.com/intel/systemc-compiler
//
//==============================================================================

//==============================================================================
//
// Module: UART_TRANSMITTER ()
//
module UART_TRANSMITTER // "system.uart_transmitter"
(
    input logic uart_transmitter_clock,
    input logic uart_transmitter_reset_active_low,
    input logic [7:0] uart_transmitter_input_btint_a[4][4],
    input logic [7:0] uart_transmitter_input_btint_b[4][4],
    input logic [1:0] uart_transmitter_input_overflow[4][4],
    input logic signed [31:0] uart_transmitter_column,
    output logic uart_transmitter_output
);

//------------------------------------------------------------------------------
// Clocked THREAD: transmit (uart_transmitter.cpp:4:1) 

// Thread-local variables
logic [23:0] transmit_WAIT_N_COUNTER;
logic [23:0] transmit_WAIT_N_COUNTER_next;
logic uart_transmitter_output_next;
logic signed [31:0] k;
logic signed [31:0] k_next;
logic signed [31:0] j;
logic signed [31:0] j_next;
logic signed [31:0] i;
logic signed [31:0] i_next;
logic [7:0] input_btint_a[4];
logic [7:0] input_btint_a_next[4];
logic signed [31:0] k0;
logic signed [31:0] k_next0;
logic [7:0] input_btint_b[4];
logic [7:0] input_btint_b_next[4];
logic [1:0] input_overflow[4];
logic [1:0] input_overflow_next[4];
logic [2:0] transmit_PROC_STATE;
logic [2:0] transmit_PROC_STATE_next;

// Next-state combinational logic
always_comb begin : transmit_comb     // uart_transmitter.cpp:4:1
    transmit_func;
end
function void transmit_func;
    integer column;
    integer input_index;
    logic [7:0] output_btint_a;
    logic [7:0] output_btint_b;
    logic [1:0] output_overflow;
    integer output_index;
    integer output_value;
    logic [7:0] output_btint_a_1;
    logic [7:0] output_btint_b_1;
    logic [1:0] output_overflow_1;
    logic [7:0] TMP_1_btint_a;
    logic [7:0] TMP_1_btint_b;
    logic [1:0] TMP_1_overflow;
    logic [7:0] TMP_0_btint_a;
    logic [7:0] TMP_0_btint_b;
    logic [1:0] TMP_0_overflow;
    input_index = 0;
    output_btint_a = 0;
    output_btint_b = 0;
    output_overflow = 0;
    output_index = 0;
    output_value = 0;
    output_btint_a_1 = 0;
    output_btint_b_1 = 0;
    output_overflow_1 = 0;
    TMP_1_btint_a = 0;
    TMP_1_btint_b = 0;
    TMP_1_overflow = 0;
    TMP_0_btint_a = 0;
    TMP_0_btint_b = 0;
    TMP_0_overflow = 0;
    i_next = i;
    input_btint_a_next = input_btint_a;
    input_btint_b_next = input_btint_b;
    input_overflow_next = input_overflow;
    j_next = j;
    k_next = k;
    k_next0 = k0;
    uart_transmitter_output_next = uart_transmitter_output;
    transmit_WAIT_N_COUNTER_next = transmit_WAIT_N_COUNTER;
    transmit_PROC_STATE_next = transmit_PROC_STATE;
    
    case (transmit_PROC_STATE)
        0: begin
            column = uart_transmitter_column;
            for (integer i_1 = 0; i_1 < 4; i_1++)
            begin
                input_btint_a_next[i_1] = uart_transmitter_input_btint_a[i_1][column]; input_btint_b_next[i_1] = uart_transmitter_input_btint_b[i_1][column]; input_overflow_next[i_1] = uart_transmitter_input_overflow[i_1][column];
            end
            i_next = 0;
            j_next = 8 - 1;
            uart_transmitter_output_next = 0;
            transmit_WAIT_N_COUNTER_next = 10000000;
            transmit_PROC_STATE_next = 1; return;    // uart_transmitter.cpp:17:17;
        end
        1: begin
            if (transmit_WAIT_N_COUNTER != 1) begin
                transmit_WAIT_N_COUNTER_next = transmit_WAIT_N_COUNTER - 1;
                transmit_PROC_STATE_next = 1; return;    // uart_transmitter.cpp:17:17;
            end;
            k_next0 = 0;
            uart_transmitter_output_next = input_btint_a_next[i_next][0];
            transmit_WAIT_N_COUNTER_next = 10000000;
            transmit_PROC_STATE_next = 2; return;    // uart_transmitter.cpp:20:21;
        end
        2: begin
            if (transmit_WAIT_N_COUNTER != 1) begin
                transmit_WAIT_N_COUNTER_next = transmit_WAIT_N_COUNTER - 1;
                transmit_PROC_STATE_next = 2; return;    // uart_transmitter.cpp:20:21;
            end;
            uart_transmitter_output_next = input_btint_b_next[i_next][0];
            input_index = 1;
            // Call shift_right() begin
            output_btint_a = 0;
            output_btint_b = 0;
            output_overflow = 0;
            output_btint_a[i_next] = input_btint_a_next[i_next];
            output_btint_b[i_next] = input_btint_b_next[i_next];
            output_overflow[i_next] = input_overflow_next[i_next];
            for (integer i_2 = 0; i_2 < input_index; i_2++)
            begin
                output_btint_a[i_next] = output_btint_a[i_next] >>> 1;
                output_btint_b[i_next] = output_btint_b[i_next] >>> 1;
                output_index = 8 - 1; output_value = 0;
                // Call set_value() begin
                output_btint_a_1 = 0;
                output_btint_b_1 = 0;
                output_overflow_1 = 0;
                output_btint_a_1 = output_btint_a;
                output_btint_b_1 = output_btint_b;
                output_overflow_1 = output_overflow;
                case (0)
                0 : begin
                    output_btint_a_1[output_index] = 0;
                    output_btint_b_1[output_index] = 1;
                end
                endcase
                TMP_1_btint_a = output_btint_a_1; TMP_1_btint_b = output_btint_b_1; TMP_1_overflow = output_overflow_1;
                // Call set_value() end
                output_btint_a = TMP_1_btint_a; output_btint_b = TMP_1_btint_b; output_overflow = TMP_1_overflow;
            end
            TMP_0_btint_a = output_btint_a; TMP_0_btint_b = output_btint_b; TMP_0_overflow = output_overflow;
            // Call shift_right() end
            input_btint_a_next[i_next] = TMP_0_btint_a; input_btint_b_next[i_next] = TMP_0_btint_b; input_overflow_next[i_next] = TMP_0_overflow;
            transmit_WAIT_N_COUNTER_next = 10000000;
            transmit_PROC_STATE_next = 3; return;    // uart_transmitter.cpp:23:21;
        end
        3: begin
            if (transmit_WAIT_N_COUNTER != 1) begin
                transmit_WAIT_N_COUNTER_next = transmit_WAIT_N_COUNTER - 1;
                transmit_PROC_STATE_next = 3; return;    // uart_transmitter.cpp:23:21;
            end;
            k_next0++;
            if (k_next0 < 4)
            begin
                uart_transmitter_output_next = input_btint_a_next[i_next][0];
                transmit_WAIT_N_COUNTER_next = 10000000;
                transmit_PROC_STATE_next = 2; return;    // uart_transmitter.cpp:20:21;
            end
            k_next = 0;
            uart_transmitter_output_next = 1;
            transmit_WAIT_N_COUNTER_next = 10000000;
            transmit_PROC_STATE_next = 4; return;    // uart_transmitter.cpp:27:21;
        end
        4: begin
            if (transmit_WAIT_N_COUNTER != 1) begin
                transmit_WAIT_N_COUNTER_next = transmit_WAIT_N_COUNTER - 1;
                transmit_PROC_STATE_next = 4; return;    // uart_transmitter.cpp:27:21;
            end;
            k_next++;
            if (k_next < 2)
            begin
                uart_transmitter_output_next = 1;
                transmit_WAIT_N_COUNTER_next = 10000000;
                transmit_PROC_STATE_next = 4; return;    // uart_transmitter.cpp:27:21;
            end
            j_next = j_next - 4;
            if (j_next >= 0)
            begin
                uart_transmitter_output_next = 0;
                transmit_WAIT_N_COUNTER_next = 10000000;
                transmit_PROC_STATE_next = 1; return;    // uart_transmitter.cpp:17:17;
            end
            i_next++;
            if (i_next < 4)
            begin
                j_next = 8 - 1;
                uart_transmitter_output_next = 0;
                transmit_WAIT_N_COUNTER_next = 10000000;
                transmit_PROC_STATE_next = 1; return;    // uart_transmitter.cpp:17:17;
            end
            column = uart_transmitter_column;
            for (integer i_1 = 0; i_1 < 4; i_1++)
            begin
                input_btint_a_next[i_1] = uart_transmitter_input_btint_a[i_1][column]; input_btint_b_next[i_1] = uart_transmitter_input_btint_b[i_1][column]; input_overflow_next[i_1] = uart_transmitter_input_overflow[i_1][column];
            end
            i_next = 0;
            j_next = 8 - 1;
            uart_transmitter_output_next = 0;
            transmit_WAIT_N_COUNTER_next = 10000000;
            transmit_PROC_STATE_next = 1; return;    // uart_transmitter.cpp:17:17;
        end
    endcase
endfunction

// Synchronous register update
always_ff @(posedge uart_transmitter_clock /*sync uart_transmitter_reset_active_low*/) 
begin : transmit_ff
    if ( ~uart_transmitter_reset_active_low ) begin
        uart_transmitter_output <= 1;
        transmit_PROC_STATE <= 0;    // uart_transmitter.cpp:8:5;
        transmit_WAIT_N_COUNTER <= 0;
    end
    else begin
        transmit_WAIT_N_COUNTER <= transmit_WAIT_N_COUNTER_next;
        uart_transmitter_output <= uart_transmitter_output_next;
        k <= k_next;
        j <= j_next;
        i <= i_next;
        input_btint_a <= input_btint_a_next;
        k0 <= k_next0;
        input_btint_b <= input_btint_b_next;
        input_overflow <= input_overflow_next;
        transmit_PROC_STATE <= transmit_PROC_STATE_next;
    end
end

endmodule


